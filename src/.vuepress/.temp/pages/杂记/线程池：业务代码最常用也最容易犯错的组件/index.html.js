export const data = JSON.parse("{\"key\":\"v-9e14ff60\",\"path\":\"/%E6%9D%82%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%9C%80%E5%B8%B8%E7%94%A8%E4%B9%9F%E6%9C%80%E5%AE%B9%E6%98%93%E7%8A%AF%E9%94%99%E7%9A%84%E7%BB%84%E4%BB%B6/\",\"title\":\"\",\"lang\":\"zh-CN\",\"frontmatter\":{\"description\":\"程序中，我们会用各种池化技术来缓存创建昂贵的对象，比如线程池、连接池、内存池。一般是预先创建一些对象放入池中，使用的时候直接取出使用，用完归还以便复用，还会通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。 由于线程的创建比较昂贵，随意、没有控制地创建大量线程会造成性能问题，因此短平快的任务一般考虑使用线程池来处理，而不是直接创建线程。 今天，我们就针对线程池这个话题展开讨论，通过三个生产事故，来看看使用线程池应该注意些什么。 线程池的声明需要手动进行 Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴Java开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和newCachedThreadPool ，可能因为资源耗尽导致 OOM 问题。\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://mister-hope.github.io/%E6%9D%82%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%9C%80%E5%B8%B8%E7%94%A8%E4%B9%9F%E6%9C%80%E5%AE%B9%E6%98%93%E7%8A%AF%E9%94%99%E7%9A%84%E7%BB%84%E4%BB%B6/\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Jankin'Blog\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"程序中，我们会用各种池化技术来缓存创建昂贵的对象，比如线程池、连接池、内存池。一般是预先创建一些对象放入池中，使用的时候直接取出使用，用完归还以便复用，还会通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。 由于线程的创建比较昂贵，随意、没有控制地创建大量线程会造成性能问题，因此短平快的任务一般考虑使用线程池来处理，而不是直接创建线程。 今天，我们就针对线程池这个话题展开讨论，通过三个生产事故，来看看使用线程池应该注意些什么。 线程池的声明需要手动进行 Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴Java开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和newCachedThreadPool ，可能因为资源耗尽导致 OOM 问题。\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"JanKin Xie\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"JanKin Xie\\\",\\\"url\\\":\\\"\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"线程池的声明需要手动进行\",\"slug\":\"线程池的声明需要手动进行\",\"link\":\"#线程池的声明需要手动进行\",\"children\":[]},{\"level\":2,\"title\":\"线程池线程管理策略详解\",\"slug\":\"线程池线程管理策略详解\",\"link\":\"#线程池线程管理策略详解\",\"children\":[]},{\"level\":2,\"title\":\"务必确认清楚线程池本身是不是复用的\",\"slug\":\"务必确认清楚线程池本身是不是复用的\",\"link\":\"#务必确认清楚线程池本身是不是复用的\",\"children\":[]},{\"level\":2,\"title\":\"需要仔细斟酌线程池的混用策略\",\"slug\":\"需要仔细斟酌线程池的混用策略\",\"link\":\"#需要仔细斟酌线程池的混用策略\",\"children\":[]},{\"level\":2,\"title\":\"重点回顾\",\"slug\":\"重点回顾\",\"link\":\"#重点回顾\",\"children\":[]}],\"readingTime\":{\"minutes\":18.17,\"words\":5452},\"filePathRelative\":\"杂记/线程池：业务代码最常用也最容易犯错的组件/README.md\",\"excerpt\":\"<p>程序中，我们会用各种池化技术来缓存创建昂贵的对象，比如线程池、连接池、内存池。一般是预先创建一些对象放入池中，使用的时候直接取出使用，用完归还以便复用，还会通过一定的策略调整池中缓存对象的数量，实现池的动态伸缩。</p>\\n<p>由于线程的创建比较昂贵，随意、没有控制地创建大量线程会造成性能问题，因此短平快的任务一般考虑使用线程池来处理，而不是直接创建线程。</p>\\n<p>今天，我们就针对线程池这个话题展开讨论，通过三个生产事故，来看看使用线程池应该注意些什么。</p>\\n<h2> 线程池的声明需要手动进行</h2>\\n<p><strong>Java</strong> 中的 <strong>Executors</strong> 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴Java开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 <strong>new ThreadPoolExecutor</strong> 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 <strong>newFixedThreadPool</strong> 和<strong>newCachedThreadPool</strong> ，可能因为资源耗尽导致 <strong>OOM</strong> 问题。</p>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
